## 進捗チェックリスト

- [x] 2章 Rustツアー
    - [x] 2.1 rustupとCargo
    - [x] 2.2 Rustの関数
    - [x] 2.3 ユニットテストの記述と実行
    - [x] 2.4 コマンドライン引数の処理
    - [x] 2.5 Webページを公開する
    - [x] 2.6 並列プログラミング
        - [x] 2.6.1 マンデルブロ集合とは
        - [x] 2.6.2 コマンドライン引数に書いた値ペアのパース
        - [x] 2.6.3 ピクセルから複素数へのマッピング
        - [x] 2.6.4 集合の描画
        - [x] 2.6.5 画像ファイルの書き出し
        - [x] 2.6.6 並列マンデルブロプログラム
        - [x] 2.6.7 マンデルブロ描画プログラムの実行
        - [x] 2.6.8 安全性は見えない
    - [x] 2.7 ファイルシステムとコマンドラインツール
        - [x] 2.7.1 コマンドラインインターフェイス
        - [x] 2.7.2 ファイルの読み書き
        - [x] 2.7.3 検索と置換

- [ ] 3章 基本的な型
    - [ ] 3.1 固定長数値
        - [ ] 3.1.1 整数型
        - [ ] 3.1.2 チェック付き演算、ラップ演算、飽和演算、オーバーフロー演算
        - [ ] 3.1.3 浮動小数点数
    - [ ] 3.2 真偽値型
    - [ ] 3.3 文字
    - [ ] 3.4 タプル
    - [ ] 3.5 ポインタ型
        - [ ] 3.5.1 参照
        - [ ] 3.5.2 Box
        - [ ] 3.5.3 rawポインタ
    - [ ] 3.6 配列、ベクタ、スライス
        - [ ] 3.6.1 配列
        - [ ] 3.6.2 ベクタ
        - [ ] 3.6.3 スライス
    - [ ] 3.7 文字列型
        - [ ] 3.7.1 文字列リテラル
        - [ ] 3.7.2 バイト文字列
        - [ ] 3.7.3 メモリ上の文字列
        - [ ] 3.7.4 文字列String
        - [ ] 3.7.5 文字列の使用
        - [ ] 3.7.6 他の文字列に類する型
    - [ ] 3.8 型エイリアス
    - [ ] 3.9 基本型の先にあるもの

- [ ] 4章 所有権と移動
    - [ ] 4.1 所有権
    - [ ] 4.2 移動
        - [ ] 4.2.1 移動を伴う他の操作
        - [ ] 4.2.2 移動と制御フロー
        - [ ] 4.2.3 移動とインデックス参照される値
    - [ ] 4.3 コピー型 : 移動の例外
    - [ ] 4.4 RcとArc : 所有権の共有

- [ ] 5章 参照
    - [ ] 5.1 値への参照
    - [ ] 5.2 参照の使い方
        - [ ] 5.2.1 Rustの参照vs C++の参照
        - [ ] 5.2.2 参照の代入
        - [ ] 5.2.3 参照への参照
        - [ ] 5.2.4 参照の比較
        - [ ] 5.2.5 参照はnullにはならない
        - [ ] 5.2.6 任意の式への参照の借用
        - [ ] 5.2.7 スライスとトレイトオブジェクトへの参照
    - [ ] 5.3 参照の安全性
        - [ ] 5.3.1 ローカル変数の借用
        - [ ] 5.3.2 仮引数として参照を受け取る場合
        - [ ] 5.3.3 参照を関数に渡す
        - [ ] 5.3.4 返り値としての参照
        - [ ] 5.3.5 参照を含む構造体
        - [ ] 5.3.6 個別の生存期間パラメータ
        - [ ] 5.3.7 生存期間パラメータの省略
    - [ ] 5.4 共有と変更
    - [ ] 5.5 オブジェクトの海に立ち向かう

- [ ] 6章 式
    - [ ] 6.1 式言語
    - [ ] 6.2 優先順位と結合性
    - [ ] 6.3 ブロックとセミコロン
    - [ ] 6.4 宣言
    - [ ] 6.5 ifとmatch
    - [ ] 6.6 if let式
    - [ ] 6.7 ループ
    - [ ] 6.8 ループ内の制御フロー
    - [ ] 6.9 return式
    - [ ] 6.10 なぜRustにはloop式があるのか
    - [ ] 6.11 関数呼び出しとメソッド呼び出し
    - [ ] 6.12 フィールドと要素
    - [ ] 6.13 参照演算子
    - [ ] 6.14 算術演算子、ビット演算子、比較演算子、論理演算子
    - [ ] 6.15 代入
    - [ ] 6.16 型キャスト
    - [ ] 6.17 クロージャ
    - [ ] 6.18 その先へ

- [x] 7章 エラー処理
    - [x] 7.1 パニック
        - [x] 7.1.1 スレッドの巻き戻し
        - [x] 7.1.2 アボート
    - [x] 7.2 Result
        - [x] 7.2.1 エラーのキャッチ
        - [x] 7.2.2 Result型のエイリアス
        - [x] 7.2.3 エラーの表示
        - [x] 7.2.4 エラーの伝播
        - [x] 7.2.5 複数種類のエラーへの対応
        - [x] 7.2.6 「起こるはずのない」エラーの処理
        - [x] 7.2.7 エラーを無視する
        - [x] 7.2.8 main()でのエラー処理
        - [x] 7.2.9 カスタムエラー型の宣言
        - [x] 7.2.10 なぜResultを使うのか

- [ ] 8章 クレートとモジュール
    - [ ] 8.1 クレート
        - [ ] 8.1.1 エディション
        - [ ] 8.1.2 ビルドプロファイル
    - [ ] 8.2 モジュール
        - [ ] 8.2.1 モジュールのネスト
        - [ ] 8.2.2 モジュールの複数ファイルへの分割
        - [ ] 8.2.3 パスとインポート
        - [ ] 8.2.4 標準のプレリュード
        - [ ] 8.2.5 use宣言をパブリックにする
        - [ ] 8.2.6 構造体のフィールドをpubにする
        - [ ] 8.2.7 staticと定数
    - [ ] 8.3 プログラムからライブラリへ
    - [ ] 8.4 src/binディレクトリ
    - [ ] 8.5 属性
    - [ ] 8.6 テストとドキュメント
        - [ ] 8.6.1 結合テスト
        - [ ] 8.6.2 ドキュメント
        - [ ] 8.6.3 ドキュメントテスト
    - [ ] 8.7 依存ライブラリの指定
        - [ ] 8.7.1 バージョン
        - [ ] 8.7.2 Cargo.lock
    - [ ] 8.8 クレートのcrates.ioでの公開
    - [ ] 8.9 ワークスペース
    - [ ] 8.10 いいものをもっと

- [ ] 9章 構造体
    - [ ] 9.1 名前付きフィールド型構造体
    - [ ] 9.2 タプル型構造体
    - [ ] 9.3 ユニット型構造体
    - [ ] 9.4 構造体のメモリ配置
    - [ ] 9.5 implによるメソッド定義
        - [ ] 9.5.1 selfをBox、Rc、Arcで渡す
        - [ ] 9.5.2 型関連関数
    - [ ] 9.6 型関連定数
    - [ ] 9.7 ジェネリック構造体
    - [ ] 9.8 生存期間パラメータを持つジェネリック構造体
    - [ ] 9.9 定数パラメータを持つジェネリック構造体
    - [ ] 9.10 一般的なトレイトの自動実装
    - [ ] 9.11 内部可変性

- [ ] 10章 列挙型とパターン
    - [ ] 10.1 列挙型
        - [ ] 10.1.1 データを保持する列挙型
        - [ ] 10.1.2 列挙型のメモリ上での表現
        - [ ] 10.1.3 列挙型を用いたリッチなデータ構造
        - [ ] 10.1.4 ジェネリック列挙型
    - [ ] 10.2 パターン
        - [ ] 10.2.1 パターン内のリテラル、変数、ワイルドカード
        - [ ] 10.2.2 タプルと構造体パターン
        - [ ] 10.2.3 配列パターンとスライスパターン
        - [ ] 10.2.4 参照パターン
        - [ ] 10.2.5 マッチガード
        - [ ] 10.2.6 複数の可能性へのマッチ
        - [ ] 10.2.7 @パターンによる束縛
        - [ ] 10.2.8 パターンが使える場所
        - [ ] 10.2.9 二分木へのデータ追加
    - [ ] 10.3 大きな絵の中での位置付け

- [ ] 11章 トレイトとジェネリクス
    - [ ] 11.1 トレイトの使い方
        - [ ] 11.1.1 トレイトオブジェクト
        - [ ] 11.1.2 ジェネリック関数と型パラメータ
        - [ ] 11.1.3 どちらを使うべきか
    - [ ] 11.2 トレイトの定義と実装
        - [ ] 11.2.1 デフォルトメソッド
        - [ ] 11.2.2 トレイトと第三者の定義した型
        - [ ] 11.2.3 トレイトでのSelf
        - [ ] 11.2.4 サブトレイト
        - [ ] 11.2.5 型関連関数
    - [ ] 11.3 完全修飾メソッド呼び出し
    - [ ] 11.4 型と型の関係を定義するトレイト
        - [ ] 11.4.1 関連型 : イテレータはどう動く
        - [ ] 11.4.2 ジェネリックトレイト : 演算子オーバーロードはどう機能するか
        - [ ] 11.4.3 impl Trait
        - [ ] 11.4.4 トレイトの関連定数
    - [ ] 11.5 制約のリバースエンジニアリング
    - [ ] 11.6 基盤としてのトレイト

- [ ] 12章 演算子オーバーロード
    - [ ] 12.1 算術演算子とビット演算子
        - [ ] 12.1.1 単項演算子
        - [ ] 12.1.2 二項演算子
        - [ ] 12.1.3 複合代入演算子
    - [ ] 12.2 等価性テスト
    - [ ] 12.3 順序比較
    - [ ] 12.4 IndexとIndexMut
    - [ ] 12.5 その他の演算子

- [ ] 13章 ユーティリティトレイト
    - [x] 13.1 Drop
    - [x] 13.2 Sized
    - [x] 13.3 Clone
    - [x] 13.4 Copy
    - [x] 13.5 DerefとDerefMut
    - [x] 13.6 Default
    - [x] 13.7 AsRefとAsMut
    - [x] 13.8 BorrowとBorrowMut
    - [x] 13.9 FromとInto
    - [ ] 13.10 TryFromとTryInto
    - [ ] 13.11 ToOwned
    - [ ] 13.12 BorrowとToOwnedの動作例 : つつましいCow

- [ ] 14章 クロージャ
    - [ ] 14.1 変数のキャプチャ
        - [ ] 14.1.1 借用するクロージャ
        - [ ] 14.1.2 盗むクロージャ
    - [ ] 14.2 関数型とクロージャ型
    - [ ] 14.3 クロージャの性能
    - [ ] 14.4 クロージャと安全性
        - [ ] 14.4.1 殺すクロージャ
        - [ ] 14.4.2 FnOnce
        - [ ] 14.4.3 FnMut
        - [ ] 14.4.4 クロージャのCopyとClone
    - [ ] 14.5 コールバック
    - [ ] 14.6 クロージャの効率的な利用

- [ ] 15章 イテレータ
    - [ ] 15.1 IteratorトレイトとIntoIteratorトレイト
    - [ ] 15.2 イテレータの作成
        - [ ] 15.2.1 iterメソッドとiter_mutメソッド
        - [ ] 15.2.2 IntoIteratorの実装
        - [ ] 15.2.3 from_fnとsuccessors
        - [ ] 15.2.4 drainメソッド
        - [ ] 15.2.5 他のイテレータの生成方法
    - [ ] 15.3 イテレータアダプタ
        - [ ] 15.3.1 mapとfilter
        - [ ] 15.3.2 filter_mapとflat_map
        - [ ] 15.3.3 flatten
        - [ ] 15.3.4 takeとtake_while
        - [ ] 15.3.5 skipとskip_while
        - [ ] 15.3.6 peekable
        - [ ] 15.3.7 fuse
        - [ ] 15.3.8 反転可能イテレータとrev
        - [ ] 15.3.9 inspect
        - [ ] 15.3.10 chain
        - [ ] 15.3.11 enumerate
        - [ ] 15.3.12 zip
        - [ ] 15.3.13 by_ref
        - [ ] 15.3.14 clonedとcopied
        - [ ] 15.3.15 cycle
    - [ ] 15.4 イテレータの消費
        - [ ] 15.4.1 単純な累積 : count、sum、product
        - [ ] 15.4.2 max、min
        - [ ] 15.4.3 max_by、min_by
        - [ ] 15.4.4 max_by_key、min_by_key
        - [ ] 15.4.5 アイテム列の比較
        - [ ] 15.4.6 any、all
        - [ ] 15.4.7 position、rposition、ExactSizeIterator
        - [ ] 15.4.8 foldとrfold
        - [ ] 15.4.9 try_foldとtry_rfold
        - [ ] 15.4.10 nthとnth_back
        - [ ] 15.4.11 last
        - [ ] 15.4.12 find、rfind、find_map
        - [ ] 15.4.13 コレクションの作成 : collectとFromIterator
        - [ ] 15.4.14 Extendトレイト
        - [ ] 15.4.15 partition
        - [ ] 15.4.16 for_eachとtry_for_each
    - [ ] 15.5 ユーザ定義イテレータの実装

- [ ] 16章 コレクション
    - [ ] 16.1 概要
    - [ ] 16.2 Vec<T>
        - [ ] 16.2.1 要素へのアクセス
        - [ ] 16.2.2 イテレート処理
        - [ ] 16.2.3 ベクタの伸長と縮小
        - [ ] 16.2.4 連結
        - [ ] 16.2.5 分割
        - [ ] 16.2.6 入れ替え
        - [ ] 16.2.7 フィル
        - [ ] 16.2.8 ソートと検索
        - [ ] 16.2.9 スライスの比較
        - [ ] 16.2.10 ランダムな要素
        - [ ] 16.2.11 Rustでは無効化エラーは生じない
    - [ ] 16.3 VecDeque<T>
    - [ ] 16.4 BinaryHeap<T>
    - [ ] 16.5 HashMap<K, V>とBTreeMap<K, V>
        - [ ] 16.5.1 エントリ
        - [ ] 16.5.2 マップに対するイテレート
    - [ ] 16.6 HashSet<T>とBTreeSet<T>
        - [ ] 16.6.1 セットのイテレート
        - [ ] 16.6.2 値が等しいが別のものの場合
        - [ ] 16.6.3 セット全体に対する演算
    - [ ] 16.7 ハッシュ
    - [ ] 16.8 ハッシュアルゴリズムのカスタマイズ
    - [ ] 16.9 標準コレクションを超えて

- [ ] 17章 文字列とテキスト
    - [ ] 17.1 Unicodeについて
        - [ ] 17.1.1 ASCII、Latin-1、Unicode
        - [ ] 17.1.2 UTF-8
        - [ ] 17.1.3 テキストの向き
    - [ ] 17.2 文字（char）
        - [ ] 17.2.1 文字の分類
        - [ ] 17.2.2 数字の取り扱い
        - [ ] 17.2.3 文字の大文字小文字変換
        - [ ] 17.2.4 整数との間の変換
    - [ ] 17.3 Stringとstr
        - [ ] 17.3.1 String値の作成
        - [ ] 17.3.2 単純な検査
        - [ ] 17.3.3 テキストの追加と挿入
        - [ ] 17.3.4 テキストの削除と置換
        - [ ] 17.3.5 検索とイテレート関数の名前付け
        - [ ] 17.3.6 パターンによるテキスト検索
        - [ ] 17.3.7 検索と置換
        - [ ] 17.3.8 テキストに対するイテレート
        - [ ] 17.3.9 トリミング
        - [ ] 17.3.10 文字列の大文字小文字変換
        - [ ] 17.3.11 他の型を文字列からパース
        - [ ] 17.3.12 他の型から文字列への変換
        - [ ] 17.3.13 他のテキストに類する型としての借用
        - [ ] 17.3.14 UTF-8としてのアクセス
        - [ ] 17.3.15 UTF-8データからのテキストの作成
        - [ ] 17.3.16 ヒープ確保の遅延
        - [ ] 17.3.17 汎用コレクションとしての文字列
    - [ ] 17.4 値のフォーマット出力
        - [ ] 17.4.1 テキスト値のフォーマット
        - [ ] 17.4.2 数値のフォーマット
        - [ ] 17.4.3 他の型のフォーマット
        - [ ] 17.4.4 デバッグのためのフォーマット
        - [ ] 17.4.5 デバッグのためのポインタのフォーマット
        - [ ] 17.4.6 インデックス、名前による引数の参照
        - [ ] 17.4.7 動的なフィールド幅
        - [ ] 17.4.8 ユーザ定義型のフォーマット出力
        - [ ] 17.4.9 フォーマット言語のユーザコードでの利用
    - [ ] 17.5 正規表現
        - [ ] 17.5.1 Regexの基本的な使い方
        - [ ] 17.5.2 Regex値の遅延作成
    - [ ] 17.6 正規化
        - [ ] 17.6.1 正規化形式
        - [ ] 17.6.2 unicode-normalizationクレート

- [ ] 18章 入出力
    - [ ] 18.1 readerとwriter
        - [ ] 18.1.1 Reader
        - [ ] 18.1.2 バッファ付きreader
        - [ ] 18.1.3 行の読み出し
        - [ ] 18.1.4 行に対するcollect
        - [ ] 18.1.5 writer
        - [ ] 18.1.6 ファイル
        - [ ] 18.1.7 シーク
        - [ ] 18.1.8 他のreader型、writer型
        - [ ] 18.1.9 バイナリデータ、圧縮、シリアライズ
    - [ ] 18.2 ファイルとディレクトリ
        - [ ] 18.2.1 OsStrとPath
        - [ ] 18.2.2 PathとPathBufのメソッド
        - [ ] 18.2.3 ファイルシステムアクセス関数
        - [ ] 18.2.4 ディレクトリの読み出し
        - [ ] 18.2.5 プラットフォーム固有機能
    - [ ] 18.3 ネットワークプログラム

- [ ] 19章 並列性
    - [ ] 19.1 フォーク・ジョイン並列
        - [ ] 19.1.1 spawnとjoin
        - [ ] 19.1.2 スレッド間でのエラー処理
        - [ ] 19.1.3 不変データのスレッド間共有
        - [ ] 19.1.4 Rayon
        - [ ] 19.1.5 マンデルブロ集合再訪
    - [ ] 19.2 チャネル
        - [ ] 19.2.1 値の送信
        - [ ] 19.2.2 値の受信
        - [ ] 19.2.3 パイプラインの実行
        - [ ] 19.2.4 チャネルの機能と性能
        - [ ] 19.2.5 スレッド安全性 : SendとSync
        - [ ] 19.2.6 ほとんどすべてのイテレータをつなげられるチャネル
        - [ ] 19.2.7 パイプライン以外のチャネルの使用法
    - [ ] 19.3 可変状態の共有
        - [ ] 19.3.1 排他ロックとは何か？
        - [ ] 19.3.2 Mutex<T>
        - [ ] 19.3.3 可変性とMutex
        - [ ] 19.3.4 排他ロックがいつもいいとは限らないのはなぜか
        - [ ] 19.3.5 デッドロック
        - [ ] 19.3.6 毒された排他ロック
        - [ ] 19.3.7 排他ロックを用いた、複数の消費者を持つチャネル
        - [ ] 19.3.8 リードライトロック（RwLock<T>）
        - [ ] 19.3.9 条件変数（Condvar）
        - [ ] 19.3.10 アトミック変数
        - [ ] 19.3.11 グローバル変数
    - [ ] 19.4 Rustでの並列コードの開発

- [ ] 20章 非同期プログラミング
    - [ ] 20.1 同期プログラムから非同期プログラムへ
        - [ ] 20.1.1 フューチャ
        - [ ] 20.1.2 async関数とawait式
        - [ ] 20.1.3 非同期関数を同期コードから呼び出す : block_on
        - [ ] 20.1.4 非同期タスクの起動
        - [ ] 20.1.5 非同期ブロック
        - [ ] 20.1.6 非同期ブロックを用いた非同期関数の記述
        - [ ] 20.1.7 非同期タスクをスレッドプールで実行
        - [ ] 20.1.8 このフューチャはSendを実装してたっけ？
        - [ ] 20.1.9 長時間の計算 : yield_nowとspawn_blocking
        - [ ] 20.1.10 非同期機構の設計
        - [ ] 20.1.11 本当に非同期なHTTPクライアント
    - [ ] 20.2 非同期なクライアントとサーバ
        - [ ] 20.2.1 Error型とResult型
        - [ ] 20.2.2 プロトコル
        - [ ] 20.2.3 ユーザ入力の取得 : 非同期ストリーム
        - [ ] 20.2.4 パケットの送信
        - [ ] 20.2.5 パケットの受信 : 非同期ストリームについてもう少し
        - [ ] 20.2.6 クライアントのmain関数
        - [ ] 20.2.7 サーバのmain関数
        - [ ] 20.2.8 チャット接続の管理 : 非同期排他ロック
        - [ ] 20.2.9 GroupTable : 同期排他ロック
        - [ ] 20.2.10 チャットグループ : tokioのブロードキャストチャネル
    - [ ] 20.3 原始的なフューチャとエグゼキュータ : フューチャを再度ポーリングするべきなのはいつか？
        - [ ] 20.3.1 ウェイカの起動 : spawn_bloking
        - [ ] 20.3.2 block_onの実装
    - [ ] 20.4 ピン留め
        - [ ] 20.4.1 フューチャの2つのライフステージ
        - [ ] 20.4.2 ピン留めされたポインタ
        - [ ] 20.4.3 Unpinトレイト
    - [ ] 20.5 非同期コードはどのような場合に使うべきか？

- [ ] 21章 マクロ
    - [ ] 21.1 マクロの基本
        - [ ] 21.1.1 マクロ展開の基礎
        - [ ] 21.1.2 意図しない結果
        - [ ] 21.1.3 繰り返し
    - [ ] 21.2 組み込みマクロ
    - [ ] 21.3 マクロのデバッグ
    - [ ] 21.4 json!マクロの構築
        - [ ] 21.4.1 フラグメント型
        - [ ] 21.4.2 マクロ中の再帰
        - [ ] 21.4.3 マクロでのトレイトの利用
        - [ ] 21.4.4 スコープと健全マクロ
        - [ ] 21.4.5 マクロのインポートとエクスポート
    - [ ] 21.5 マッチ中のシンタックスエラーを避ける
    - [ ] 21.6 macro_rules!よりも複雑なマクロ

- [ ] 22章 unsafeなコード
    - [ ] 22.1 何に対してunsafeなのか？
    - [ ] 22.2 unsafeブロック
    - [ ] 22.3 例 : 効率的なASCII文字列型
    - [ ] 22.4 unsafe関数
    - [ ] 22.5 unsafeブロックかunsafe関数か？
    - [ ] 22.6 未定義動作
    - [ ] 22.7 unsafeトレイト
    - [ ] 22.8 rawポインタ
        - [ ] 22.8.1 rawポインタを安全に参照解決するには
        - [ ] 22.8.2 例 : RefWithFlag
        - [ ] 22.8.3 nullとなり得るポインタ
        - [ ] 22.8.4 型のサイズとアラインメント
        - [ ] 22.8.5 ポインタ演算
        - [ ] 22.8.6 メモリに移動、メモリから移動
        - [ ] 22.8.7 例 : GapBuffer
        - [ ] 22.8.8 unsafeなコードのパニック安全性
    - [ ] 22.9 共用体を用いたメモリの再解釈
    - [ ] 22.10 共用体に対するマッチ
    - [ ] 22.11 共用体の借用

- [ ] 23章 外部言語関数
    - [ ] 23.1 共通のデータ表現を見つける
    - [ ] 23.2 外部言語関数、変数の宣言
    - [ ] 23.3 ライブラリ関数の使用
    - [ ] 23.4 libgit2の
    - [ ] 23.5 libgit2に対する安全なインターフェイス
    - [ ] 23.6 結論