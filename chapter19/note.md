# 19章 並列性 を読んでのメモ書き

なんとなくだけど、並列プログラミングは怖い。。

## 19.1 フォーク・ジョイン並列

- フォーク/ジョインのモデルは様々な言語で実装されているので、大体わかるはず。。
- join完了後に結果の統合が必要になるので、よく考えて使う
- 分割可能な操作にしないとあまり意味がない
- 真面目にサンプル動かそうと考えると、loadとsave書かなきゃいけないな。。
### 19.1.1 spawnとjoin
- この辺なんとなく、”並行プログラミング入門”読んだときに書いてあったな。。
- fork/joinでよくやるスタイルなので素直に読んでよいか。。
- RustっぽくするならWorklistはイテレータにしてfor_eachとか？

### 19.1.2 スレッド間でのエラー処理
- パニックしたか/してないかがResultとしてわかる。
  - 凄い助かる
- Resultだからjoinをしてるスレッドに値を返せる
  - c++だったらすげぇややこしいのやらねばならぬ。。
  - 「あ〜、これ未定義動作ですね」と言われない

### 19.1.3 不変データのスレッド間共有

- 14章の「盗むクロージャ」はあとで見る
- まるごとコピーして子スレッドに渡すのは避けたい。
  - 状況いかんでは使うかも
- Arcを使えば不変データもスレッド間共有できる
  - あくまで参照なので元データをコピーしない
  - デッドロック起こすような参照の場合はMutexかな？

### 19.1.4 Rayon

- spawn/joinをうまいことやってくれる
- ”並列イテレータ”がイテレータと変わらない使い勝手
  - 処理の分割は適当にやってくれる
  - par_iter()カコいい

### 19.1.5 マンデルブロ集合再訪
- [x] あとでRayon使って再実装してみる
- スレッドのマネージメントはクレートにやらせよう
  - 75%も速度が改善したのはすごい。。

速度の改善結果確認

```bash
# in chaper 19 dir. using rayon
$ time target/debug/mandelbrot mandel_rayon.png 4000x3000 -1.20,0.35 -1,0.20
real    0m30.894s
user    1m45.340s
sys     0m0.025s
# in chapter02 dir. 
$ time target/debug/mandelbrot mandel_rayon.png 4000x3000 -1.20,0.35 -1,0.20

real    0m30.503s
user    1m48.222s
sys     0m0.033s

```

## 19.2 チャネル
### 19.2.1 値の送信
### 19.2.2 値の受信
### 19.2.3 パイプラインの実行
### 19.2.4 チャネルの機能と性能
### 19.2.5 スレッド安全性 : SendとSync
### 19.2.6 ほとんどすべてのイテレータをつなげられるチャネル
### 19.2.7 パイプライン以外のチャネルの使用法
## 19.3 可変状態の共有
### 19.3.1 排他ロックとは何か？
### 19.3.2 Mutex<T>
### 19.3.3 可変性とMutex
### 19.3.4 排他ロックがいつもいいとは限らないのはなぜか
### 19.3.5 デッドロック
### 19.3.6 毒された排他ロック
### 19.3.7 排他ロックを用いた、複数の消費者を持つチャネル
### 19.3.8 リードライトロック（RwLock<T>）
### 19.3.9 条件変数（Condvar）
### 19.3.10 アトミック変数
### 19.3.11 グローバル変数
## 19.4 Rustでの並列コードの開発