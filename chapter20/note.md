
# 20章 非同期プログラミング

この章で学ぶ内容。ちょっと迷子になりそうなので整理
- 非同期プログラムの基本 (20.1.1~20.1.4)
- 非同期ブロックとspawnエグゼキュータ　(20.1.5~20.1.11)
- 実際のコードの紹介　(20.2)
- エグゼキューターの自前実装(20.3)
- Pin型とその使い方(20.4)

超長そう。。。

## 20.1 同期プログラムから非同期プログラムへ
### 20.1.1 フューチャ
- Future: poll()関数により、処理が終了して値が返っているかをチェックできるトレイト
- async-std:非同期版のstd
  - Resultが返るのではなくFutureが返る
  - 可能な限り忠実にstdの関数を再現してる
  - ポーリングの管理凄い大変そう。。
    - ->ちゃんといい感じにしてくれる機能が有る(次節)
### 20.1.2 async関数とawait式
- async fnの中でFutureに対して.awaitを使うとFutureのデータが使用可能になるまで待機する
- async fn f(...)-> T　のような関数定義があった場合、TのFutureが返る
  - The Bookでこの辺やったか？
  - 項目が無い。。。やってない。。
- トレイトは非同期メソッドを持てない
  - async-traitを使用するとマクロでうまく解決できる
  - 今の所、asyncブロックを作ってその中で非同期実行するのがベターな設計っぽいな(複雑なトレイト構造になると面倒だけど。。)
### 20.1.3 非同期関数を同期コードから呼び出す : block_on
- task::block_on()はFutureを受け取り継続してポーリングしてくれる
  - async関数にしなくても使える
  - task::spawn()とかも有るので、色々試してみたい
- 再度ポーリング可能になるタイミングでうまくポーリングしてくれるので、ループ回すより効率良い
  - 実装の詳細は20.3節でやるのでお楽しみ
    - [ ] 面白かった？
- [ ] 個々までのcheapo_request()の実装とお試しを
### 20.1.4 非同期タスクの起動
- block_onは結局ビジーウェイトすることになる。この点はawait使った場合と一緒。
- spawn_local ：プールにFutureを追加していく。block_on実行中のスレッドで呼ばれると、プール中のFutureが実行される
  - task::spawn()との違いは？
    - ->引数がクロージャである点/spawn_local()はFutureを引数に取る
    - spawn_localはプールしてblock_onが呼ばれるまで実行されない
- 通常のRustコードとあまり変わらない書き方ができる旨を強調してるのはなぜ？
### 20.1.5 非同期ブロック
- 関数じゃなくてもasyncキーワードをつければブロック単位で非同期にできる
- [ ]14.1.2 盗むクロージャをチェック
- 末尾の型を明示しないと、コンパイラに怒られる
### 20.1.6 非同期ブロックを用いた非同期関数の記述
- 非同期ブロックをそのままFutureとして返すことができる
- 'staticは省略できる
- 
### 20.1.7 非同期タスクをスレッドプールで実行
- [ ] task_local!() マクロの参照
- spawnは非同期実行できる

### 20.1.8 このフューチャはSendを実装してたっけ？
- spawnはSendトレイトを実装していなければならない
- Sendではないトレイト(Rcとか)を使う場合には？
  - ブロックを作ってスコープから外す
  - Arcを使う
- Sendかどうかは書いてるうちに覚える
### 20.1.9 長時間の計算 : yield_nowとspawn_blocking
- yield_nowで、スレッドを解放して一旦他のタスクに実行権を渡す
- spawn_blokingはFutureをawaitすることで、時間のかかる計算を他のスレッドに渡せる

### 20.1.10 非同期機構の設計
- ポーリングしないと実行されない非同期機構のスタイルは珍しい
- ”エグゼキュータ”がRustの非同期機構の根本
- tokioにも独自のエグゼキュータが実装されてる
- エグゼキュータの自前実装はこの章の最後にやる

### 20.1.11 本当に非同期なHTTPクライアント
- 実装例の紹介
- [ ] プログラム書いてみる
## 20.2 非同期なクライアントとサーバ
実装する章なのでメモは適当になるかも。

とりあえず、2.10まで実装して動作確認完了。
### 20.2.1 Error型とResult型
クレート全体で使う汎用のエラー型の定義大事！

### 20.2.2 プロトコル
- serde使ってる例はあちこちで見るけど、やっぱり便利
  - ちょっとしたパーサをさくっと作れるのでプロトコルの構築とか楽

### 20.2.3 ユーザ入力の取得 : 非同期ストリーム
- Streamトレイト
  - 非同期に使えるイテレータ
  - IteratorトレイトとFutureをガッチャンコ
  - nextではなくpoll_next()を使ってFutureのように次の値を得る
- lineseメソッドは正確にはStreamトレイトではなくLines構造体を返している
  - Lines構造体はStreamトレイトをimplしているので、Streamトレイトとして振る舞える
  - 本の説明は間違ってないけど一応。ソース読むと初見時若干混乱する。
  - ただ、この設計は非常に好き。
### 20.2.4 パケットの送信
- outboundを抽象化している理由は？

### 20.2.5 パケットの受信 : 非同期ストリームについてもう少し
- ストリームの使い方は参考になる。
- 非同期プログラミングの感覚わかってきた気がする
- asyncにしなくてもストリーム返すだけで遅延評価できるから、うまく非同期と連携できる

### 20.2.6 クライアントのmain関数
- raceの使い方参考

### 20.2.7 サーバのmain関数
- log_error でserveを包むのなんか違和感あるけど、コレが良い方法なのかも
### 20.2.8 チャット接続の管理 : 非同期排他ロック
- async_std::sync::Mutexを使う
- stdのMutexやばいやろ。。
- ”グチャグチャになったJSONが届くことになる”
  - デバッグ中に届いたんやろな。。

### 20.2.9 GroupTable : 同期排他ロック
- こちらでは非同期市内からｓｔｄ::sync::Mutexを使う

### 20.2.10 チャットグループ : tokioのブロードキャストチャネル
- tokio便利
## 20.3 原始的なフューチャとエグゼキュータ : フューチャを再度ポーリングするべきなのはいつか？
ここも実装っぽいけど、粗くしか書かれていないので、一旦パス
- [ ] 原始的なFutureの実装をしてみる 
### 20.3.1 ウェイカの起動 : spawn_bloking
-
### 20.3.2 block_onの実装
- parkerさえ実装できてしまえば、非常に単純に実装できる
- pin!マクロ出てきてる
## 20.4 ピン留め

### 20.4.1 フューチャの2つのライフステージ
- フューチャは一度ポーリングしたら移動できない
### 20.4.2 ピン留めされたポインタ
- pin!した状態にしておけば、as_mutで取得して再借用できる
### 20.4.3 Unpinトレイト

- Pinしたオブジェクトを再び
- unsafeなことを色々やる可能性あるのでビビるなぁ。。

## 20.5 非同期コードはどのような場合に使うべきか？
- 乱用は良くない
- ポイント
  - メモリ消費量
  - タスク生成の速度
  - コンテキストスイッチの速度がポイント
