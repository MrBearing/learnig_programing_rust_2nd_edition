
# 20章 非同期プログラミング

この章で学ぶ内容。ちょっと迷子になりそうなので整理
- 非同期プログラムの基本 (20.1.1~20.1.4)
- 非同期ブロックとspawnエグゼキュータ　(20.1.5~20.1.11)
- 実際のコードの紹介　(20.2)
- エグゼキューターの自前実装(20.3)
- Pin型とその使い方(20.4)

超長そう。。。

## 20.1 同期プログラムから非同期プログラムへ
### 20.1.1 フューチャ
- Future: poll()関数により、処理が終了して値が返っているかをチェックできるトレイト
- async-std:非同期版のstd
  - Resultが返るのではなくFutureが返る
  - 可能な限り忠実にstdの関数を再現してる
  - ポーリングの管理凄い大変そう。。
    - ->ちゃんといい感じにしてくれる機能が有る(次節)
### 20.1.2 async関数とawait式
- async fnの中でFutureに対して.awaitを使うとFutureのデータが使用可能になるまで待機する
- async fn f(...)-> T　のような関数定義があった場合、TのFutureが返る
  - The Bookでこの辺やったか？
  - 項目が無い。。。やってない。。
- トレイトは非同期メソッドを持てない
  - async-traitを使用するとマクロでうまく解決できる
  - 今の所、asyncブロックを作ってその中で非同期実行するのがベターな設計っぽいな(複雑なトレイト構造になると面倒だけど。。)
### 20.1.3 非同期関数を同期コードから呼び出す : block_on
- task::block_on()はFutureを受け取り継続してポーリングしてくれる
  - async関数にしなくても使える
  - task::spawn()とかも有るので、色々試してみたい
- 再度ポーリング可能になるタイミングでうまくポーリングしてくれるので、ループ回すより効率良い
  - 実装の詳細は20.3節でやるのでお楽しみ
    - [ ] 面白かった？
- [ ] 個々までのcheapo_request()の実装とお試しを
### 20.1.4 非同期タスクの起動
- block_onは結局ビジーウェイトすることになる。この点はawait使った場合と一緒。
- spawn_local ：プールにFutureを追加していく。block_on実行中のスレッドで呼ばれると、プール中のFutureが実行される
  - task::spawn()との違いは？
    - ->引数がクロージャである点/spawn_local()はFutureを引数に取る
    - spawn_localはプールしてblock_onが呼ばれるまで実行されない
- 通常のRustコードとあまり変わらない書き方ができる旨を強調してるのはなぜ？
### 20.1.5 非同期ブロック
- 関数じゃなくてもasyncキーワードをつければブロック単位で非同期にできる
- [ ]14.1.2 盗むクロージャをチェック
- 末尾の型を明示しないと、コンパイラに怒られる
### 20.1.6 非同期ブロックを用いた非同期関数の記述
- 非同期ブロックをそのままFutureとして返すことができる
- 'staticは省略できる
- 
### 20.1.7 非同期タスクをスレッドプールで実行
- [ ] task_local!() マクロの参照
- spawnは非同期実行できる

### 20.1.8 このフューチャはSendを実装してたっけ？
- spawnはSendトレイトを実装していなければならない
- Sendではないトレイト(Rcとか)を使う場合には？
  - ブロックを作ってスコープから外す
  - Arcを使う
- Sendかどうかは書いてるうちに覚える
### 20.1.9 長時間の計算 : yield_nowとspawn_blocking
- yield_nowで、スレッドを解放して一旦他のタスクに実行権を渡す
- spawn_blokingはFutureをawaitすることで、時間のかかる計算を他のスレッドに渡せる

### 20.1.10 非同期機構の設計
- ポーリングしないと実行されない非同期機構のスタイルは珍しい
- ”エグゼキュータ”がRustの非同期機構の根本
- tokioにも独自のエグゼキュータが実装されてる
- エグゼキュータの自前実装はこの章の最後にやる

### 20.1.11 本当に非同期なHTTPクライアント
- 実装例の紹介
- [ ] プログラム書いてみる
## 20.2 非同期なクライアントとサーバ
実装する章なのでメモは適当に。
### 20.2.1 Error型とResult型
### 20.2.2 プロトコル
### 20.2.3 ユーザ入力の取得 : 非同期ストリーム
### 20.2.4 パケットの送信
### 20.2.5 パケットの受信 : 非同期ストリームについてもう少し
- ストリームの使い方は参考になる。
- 非同期プログラミングの感覚わかってきた気がする
- asyncにしなくてもストリーム返すだけで遅延評価できるから、うまく非同期と連携できる



### 20.2.6 クライアントのmain関数
### 20.2.7 サーバのmain関数
### 20.2.8 チャット接続の管理 : 非同期排他ロック
### 20.2.9 GroupTable : 同期排他ロック
### 20.2.10 チャットグループ : tokioのブロードキャストチャネル
## 20.3 原始的なフューチャとエグゼキュータ : フューチャを再度ポーリングするべきなのはいつか？
### 20.3.1 ウェイカの起動 : spawn_bloking
### 20.3.2 block_onの実装
## 20.4 ピン留め
### 20.4.1 フューチャの2つのライフステージ
### 20.4.2 ピン留めされたポインタ
### 20.4.3 Unpinトレイト
## 20.5 非同期コードはどのような場合に使うべきか？